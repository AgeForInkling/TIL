# React의 Virtual DOM에 대해서

[벨로퍼트의 한 번역글](<https://velopert.com/3236>)을 참조하였습니다.

#### 1. 간략히, 많은 사람들이 대충 답변해주는 사실

DOM 조작이 비효율적이기 때문에 Virtual DOM을 쓴다. 
그렇다면 왜 DOM 조작이 비효율적이라고 하는 걸까?

#### 2. 브라우저의 작동 방식

 1. DOM Tree 생성 

    HTML을 토대로 브라우저가 DOM 노드로 이루어진 트리를 만듬. 노드는 각 HTML 엘리먼트와 연관되어 있습니다.

 2. Render Tree 생성
    외부 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱. 스타일 정보를 사용하여 DOM Tree에 따라 새로운 트리를 만듬. DOM Tree + CSS라고 생각하면 될듯?
    Render Tree를 만드는 과정에선 각 엘리먼트의 스타일을 계산하고, 다른 요소의 스타일 속성을 참조한다고 함
    하지만 DOM Tree와 1:1로 대응하는 관계는 아닌게, head와 같은 태그는 비시각적 요소이므로 렌더트리에 추가되지 않는다. display:none 과 같은 값이 할당된 요소도 렌더트리에 나타나지 않는다.

 3. Layout(배치)
    각 노드가 스크린의 어디에 배치될지 좌표가 주어지는 단계

 4. Painting

    각노드의 paint() 메소드를 호출하고, 끝나면 스크린에 원하는 정보가 나타나게됨

#### 3. DOM 조작의 문제

조작이 레이아웃 변화, 트리 변화, 렌더링을 일으킨다는 점. 그래서 30개의 노드를 하나 하나 수정하게 되면 약 30번의 레이아웃 재계산과 리렌더링을 일으킨다는 점.

#### 4. Virtual DOM

DOM 차원에서 더블 버퍼링과 다름이 없다. 변화가 일어나면 오프라인 DOM 트리에 적용을 시키고(렌더링 일어나지 않음), 모든 연산이 끝나면 최종 변화를 실제 DOM에 던져준다. 그래서 딱 한번만 모든 변화를 하나로 묶어서, 레이아웃 계산과 렌더링 규모는 커지지만, 딱 한번 한다는 점이 핵심.

Virtual DOM 없이도 변화를 묶어서 DOM fragment에 적용한 다음 기존 DOM에 던져주는 방식으로 충분히 구현할 수 있다. 문제는 무엇이 바뀌었는지 바뀌지 않았는지 계속 파악하고 있어야하는데(필요한 부분만 업데이트하기위해) 이 작업을 자동으로 Virtual DOM이 해준다는 점이다.

#### 5. 오해

리액트는 DOM보다 빠른가? - 그렇지 않다. 리액트는 유지보수를 쉽게 해주는 것에 초점이 맞춰져 있고, 그리고 대부분의 경우 충분히 빠르기 때문에 쓴다는 것. DOM최적화 작업을 손수 잘 했을때에 대부분 리액트보다 빠르다고 한다. 하지만 조금의 속도를 포기하고 얻는 생산성이 아주 크다는 것.


