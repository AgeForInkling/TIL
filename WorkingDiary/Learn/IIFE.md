# IIFE

Immediately Invoked Function Expressions, Iffy라고 발음한다네요. 즉시 호출 함수 표현식의 줄임말입니다.

### 기본형태

```js
( function () {
  // do something
})();
//or
var someValue = function () {
  // do something
}();
```

함수를 실행만 하려면 함수를 묶는 괄호를 써줘야 하고, 할당하는 거면 안 써주고 끝에 `()`로 실행만 해주면 된다.

### 함수의 선언과 표현의 차이

```js
foo(); //success 선언식
function foo(){}

foo(); //fail 표현식
var foo = function(){};

foo(); //fail IIFE
(function foo(){});
foo(); //fail
```

선언식은 미리 실행컨텍스트에 로딩되어 어디서든 호출될 수 있고(호이스팅), 표현식은 인터프리터가 해당 라인에 도달하여야 호출될 수 있다는 점이 다른점이네요.  IIFE에서는(실행하지 않았으므로 IIFE가 아니긴한데) 선언식의 함수를 괄호로 감싸 표현식과 같이 표현할 수 있습니다. `foo`라는 변수를 건드리지 않았다는 점에 주목하면 될 것 같습니다.

### 언제 사용하나요?

1. 전역 스코프를 오염 시키지 않기 위해

   jQuery를 쓰는 개발자들이 특히 많이들 쓴다고 합니다. 지역 변수를 익명 함수 내부에 위치시켜 외부와의 충돌을 방지합니다.

2. 익명함수가 변하는 변수를 참조할때

   ```js
   function foo(arr){
     for(var i=0;i<arr.length;i++){
     	  arr[i] = function(){
           return i+100;
         }();
       //arr[i] = i+100;
     }
     return arr; 
   }
   ```

   위의 코드에서 익명의 함수에 `()`를 붙여 실행하지 않고 함수를 `arr`에 넣어 리턴하고 그 함수를 나중에 실행하게 되면 `i=3`인 상태에서 `i`를 참조하기 때문에 원하는대로 동작하지 않습니다. 그래서 원하는시점에 바로 함수를 실행하고 그 결과를 `arr[i]` 넣는 것이 원하는 결과를 가져옵니다. 사실 설명을 위해 만든 억지스러운 코드지만 개념만 참고하면 됩니다. 

   그렇다면 `arr[i]`는 어떻게 제대로 동작하는 것일까요? `arr[i]`는 선언이 아니라 호출의 동작입니다. 주석의 `arr[i] = i+100`의 코드도 `i`를 선언만 하고 나중에 호출하는 것이 아니라 당장 저 코드가 쓰인 순간 `i`가 호출되죠. 요점은 내가 쓴 코드가 지금 호출될 것이냐, 나중에 호출될 것이냐를 생각하면 된다는 말입니다.